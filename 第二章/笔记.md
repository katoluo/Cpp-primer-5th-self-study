# 第2章 变量和基本类型

`记录一些可以带来一点通的知识点`



- 当我们赋给一个带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。

```
我们知道signed char能表示的范围为-128～127
我们举些例子：
当我们把如下对象c赋值为128时，超出了它的表示范围了，但是这样的代码是可以编译成功并运行的。结果输出c为-128。
signed char c = 128;
std::cout << (int)c << std::endl; // 输出-128
我的理解是：由于我现在还没有深入了解，但是我觉得应该会是我想的这样；首先，我们给signed char对象赋值一个int类型的字面值，128的二进制表示为0000 0000 0000 0000 0000 0000 1000 0000；
这样一个32位二进制串赋值给8位的signed char对象时，进行了某规则的砍掉多余的比特，把后8位比特赋值给c，然后c的二进制表示即为1000 0000，由于有符号整数采取补码表示，那么c的二进制表示就为-128。
下面这个例子：
signed char c2 = 257;
std::cout << (int)c2 << std::endl; // 输出1
第一个例子在编译过程中：g++ -Wall xxxx.cpp --std=c++11；不会发出警告之类的信息。
在第二个例子会发出警告，overflow之类的，当时可以编译通过，输出1。
其实道理跟例子一样，257：0000 0000 0000 0000 0000 0001 0000 0001；然后8位赋值给了c2，就为1了。
```

- **含有无符号类型的表达式**

```
当表达式中既有无符号类型又有带符号类型，带符号类型会转换成无符号数，然后进行计算等。
无符号数是不可能小于零的，当两个无符号数相减为负数时，将这个负数的二进制补码表示直接赋值给无符号的表示法，相同的内存里面相同的二进制串，但是类型的不一样，编译器还是操作系统就会采用不同的解释，会把这个负数解释为无符号时的表示。
```

- **字面值常量**

```
整型字面值可以写作十进制、八进制或十六进制数的形式，具体的类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，int、long、long long中可容纳的最小的那个；八进制和十六进制字面值既可能是带符号的页可能是无符号的，int、unsigned int、long、unsigned long、long long、unsigned long long中尺寸最小者。类型short没有对应的字面值。
尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。负号不在字面值之内，它的作用仅仅是对字面值取负值而已。
浮点数字面值默认是一个double类型。
字符字面值，'a'。
字符串字面值，"Hello world"，实际上是由常量字符构成的数组，编译器在每个字符串结尾添加空字符'\0'，长度加1。
```

- **转义序列**

```
泛化的转义字符，其形式是\x后跟1个或多个十六进制数字，或者\后跟1个、2个、3个八进制数字，其中数字部分表示的是字符对应的数值。
如果\后跟的八进制数字超过3个，那么与\的前三个八进制数字构成一个字符然后超过的表示它自己的字符。
转义序列表示字符嘛，一般都是一个字节，八个比特，假设\x后跟超过两位的十六进制数字，那么便超过8位，可能会报错。深入了解的话应该配合某些前缀作为开头的扩展字符集一起使用。
```

- **指定字面值的类型**

```
添加前缀和后缀可以改变整型、浮点型和字符型字面值的默认类型。
L'a'	// 宽字符型字面值，类型是wchar_t
u8"Hello"	// utf-8字符串字面值 类型char
42ULL	// 无符号整型字面值， 类型unsigned long long
1E-3F	// 单精度浮点型字面值， 类型float
3.14159L	// 扩展精度浮点型字面值，类型是long double
简单了解，有点印象。
```

- **变量**

```
变量提供一个具名的、可供程序操作的存储空间。C++的每个变量都有其数据类型，数据类型决定着变量所占内存的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。
```

- **变量声明和定义的关系** 

```
变量能且只能被定义一次，但是可以被声明多次；
为什么需要变量的声明？我们一直使用istream、ostream类型的对象std::cin、std::cout，它们都定义在别的文件，那么就需要在使用该对象时就需要声明，让本程序知道这个名字，以便程序能够使用；
声明使得名字为程序所知，一个文件如果相使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。
声明定义别处文件的对象，需要使用extern关键字。
extern int i;	// 声明i而非定义i
int j;			// 声明并定义j
全局：extern int i = 10;	// 抵消了extern的作用，变成定义了。
局部：extern int i = 10;	// 引发错误。
```

- **默认状态下，const 对象仅在文件内有效**

```cpp
const int bufSize = 512; // 编译过程中把用到该变量的地方都替换成对应的值
const int bufSize = getValue(); // 运行时把用到该变量的地方都替换成对应的值
//多文件共享同一个const对象的方法：
extern const int bufSize = fcn(); // file_1.cpp定义并初始化了一个常量，能被其他文件访问
extern const int bufSize; // file_1.h头文件，与file_1.cpp中定义的bufSize是同一个
```

- **const 的引用**

```cpp
const int ci = 1024;	// 定义并初始化一个const对象ci
const int &r1 = ci;		// 对ci起一个别名r1
r1 = 42;				// 试图通过别名对一个const对象进行更改值，是非法的。
int &r2 = ci;			// 试图将一个非常量的对象绑定到一个常量对象，是非法的。
```

- **初始化和对const 的引用**

```cpp
在这之前我们都知道引用的类型必须与其所引用的对象的类型一致，但是有两个例外。第一种例外就是在初始化一个常量引用时允许对任意表达式作为初识值，只要表达式的结果能转换成引用的类型即可。尤其，允许一个常量引用绑定到非常量的对象、字面值：
int i = 42;
const int &r1 = i;	// 允许将const int&绑定到一个普通int对象上
const int &r2 = 42;	// 合法：r2是一个常量引用
const int &r3 = r1 * 2;	// 合法：r3是一个常量引用
int &r4 = r1 * 2;	// 不合法：r4是一个非常量引用

double dval = 3.14;
const int &ri = dval;
// 编译器会对上述操作进行如下替换：
const int temp = dval;
const int &ri = demp; // ri绑定了一个临时量
```

- **指针和const**

```cpp
我们可以用一个非常量的对象来初始化一个指向常量的指针，如：
int i = 10;
const int *ip = &i; // 不能通过指针ip去修改指向对象的值
但是不能用一个const的对象来初始化一个非常量的指针，如：
const int ci = 10;
int *p = &ci; // 错误，因为普通指针可以修改指向的值，而指向的对象是const的，不可以这样。
```

- **顶层const和底层const**

```cpp
指针本身一个对象，可以指向另外一个对象。因此指针本身是不是常量以及指针指向的是不是一个常量是两个独立的问题。用名词顶层const表示指针本身是个常量，而用名词底层const表示指针指向的对象是一个常量。
```

- **constexpr和常量表达式**

```
常量表达式(const expression)是指值不会改变并且在编译过程就能的到计算结果的表达式。在之前说道const的时候，就有说到编译时将const变量的名字全都替换成值进行处理；有时是在运行时才能得到计算的结果，例如用函数的返回值来初始化一个const对象。常量表达式大概是第一种。
```

- **constexpr变量**

```cpp
// constexpr的变量必须用常量表达式初始化
constexpr int mf = 20; // 20是常量表达式
constexpr int limit = mf + 1; // mf + 1是常量表达式
constexpr int sz = size();	// 只有当size是一个constexpr函数时才是一条正确的声明语句
```

- **指针和constexpr**

```cpp
指针和引用都能定义成constexpr，但初识值收到严格限制；一个constexpr指针的初识值必须是nullptr或者0,或者是存储在某个固定地址中的对象，函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这些变量；相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。
限定符constexpr仅对指针有效，与指针所指的对象无关：
const int *p = nullptr; // p是指向int常量的指针 底层const
constexpr int *q = nullptr; // q是指向int的常量指针 顶层const
constexpr指针既可以指向常量也可以指向非常量：
int j = 0; // 必须定义在函数体外
constexpr int i = 42; // 定义函数体之外
constexpr int *p = &i; // p是常量指针，指向整型常量i
constexpr int *p1 = &j; // p1是常量指针，指向整型j
```

- **auto 类型说明符**

```cpp
使用auto也能在一条语句中声明多个变量。
编译器推断出来的auto类型有时候和初识值的类型并不完全一样。

```

- **decltype 类型指示符**

```cpp
有时我们希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。
decltype的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值。
decltype(f()) sum = x; // sum 的类型就是函数f的返回类型
decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&
decltype(cj) z; // 错误：z是一个引用，必须初始化
如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型：
// decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r+0) b; // 正确：加法的结果是int，因此b是一个(未初始化的)int
decltype(*p) c; // 如果表达式的内容是解引用操作，则decltype将得到引用类型
特别：
// decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d; // 错误，d是int&，必须初始化
decltype(i) e; // 正确，e是一个(未初始化的)int
```

