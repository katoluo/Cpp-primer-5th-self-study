# 第四章 表达式

- **表达式**

```
表达式由一个或多个运算符对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或者多个运算对象组合起来可以生成较复杂的表达式。
```

- **左值和右值**

```
C++的表达式要不然是右值，要不然就是左值。一个左值表达式的求值结果是一个对象或者一个函数，然后以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。总结：当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)。
到目前我们熟悉的几种运算符是要用到左值的：
赋值运算符需要一个(非常量)左值作为其左侧运算符对象，得到的结果也仍然是一个左值。
取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值。
```

- **取余运算(求模)**

```cpp
m % (-n) == m % n;
(-m) % n == -(m % n);
```

- **赋值运算满足右结合律**

```cpp
int ival, jval;
ival = jval = 0;
```

- **赋值运算符**

```
赋值运算符的左侧运算对象必须是可修改的左值，其结果就是左侧运算对象；如果左右侧对象的类型不一样，并且右侧对象可以转换成左侧对象，右侧对象的类型会被转换成左侧对象的类型，如果不能转换的话，这样的表达式是错误的。
```

- **递增和递减运算符**

```
递增和递减运算符有两种形式：前置版本和后置版本。都需要作用在可修改的左值上，前置版本的运算结果是将已经修改的对象作为左值返回，所以我们可以进行这样的编写：
int i = 1; ++i = 3; --i = 4; // 这里想表达的是前置版本的结果是一个左值
后置版本的结果是返回对象原始值的副本，是一个右值，所以我们不能写上面那样的代码。
```

- **移位运算符**

```
使用一个简单的例子来做回忆点：
unsigned char bits = 0223;
bits << 8; // unsigned char会被提升成int类型
```

- **求值顺序也是一个很有趣的东西，需要了解一下**

```
逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。
```

- **逗号运算符**

```
逗号运算符有两个运算对象，求值顺序从左向右依次求值；逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。
```

- **类型转换之何时发生隐式类型转换**

```
在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
在条件中，非布尔值准环成布尔类型。
初始化过程中，初识值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
如果算术运算或关系运算的运算对象有多种类型，需要转换成同一类型。
函数调用时也会发生类型转换。
```

- **显示类型转换**

```
命名的强制类型转换：
cast-name<type>(expression);
其中type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。
```

